#!perl

# check_lm_sensors is a Nagios plugin to monitor the values of on board sensors and hard
# disk temperatures on Linux systems
#
# See  the INSTALL file for installation instructions
#
# Copyright (c) 2007, ETH Zurich.
#
# This module is free software; you can redistribute it and/or modify it
# under the terms of GNU general public license (gpl) version 3.
# See the LICENSE file for details.
#

# RCS information (required by Perl::Critic)
#   $Id$
#   $Revision$
#   $HeadURL$
#   $Date$

use strict;
use warnings;

use Getopt::Long;
use Carp;
use English qw(-no_match_vars);
use List::MoreUtils qw(apply);
use Readonly;

use Data::Dumper;

use Nagios::Plugin;

use version; our $VERSION = '4.0.0';

my $converted_name;
my $criticals;
my $desc;
my $drives;
my $hddtemp_bin;
my $help;
my $limits;
my $list;
my $name;
my $plugin;
my $prog_name;
my $result;
my $sensors;
my $space;
my $status;
my $unknowns;
my $verbosity;
my $warnings;
my %highs;
my %lows;
my %rename;
my %ranges;
my %sensor_values;
my @drives;

# initialization
$criticals = q{};
$desc      = q{};
$drives    = 1;
$help      = q{};
$prog_name = 'LM_SENSORS';
$plugin    = Nagios::Plugin->new( shortname => $prog_name );
$sensors   = 1;
$space     = q{};
$status    = q{};
$unknowns  = q{};
$verbosity = 0;
$warnings  = q{};

##############################################################################
# subroutines

##############################################################################
# Usage     : verbose("some message string", $optional_verbosity_level);
# Purpose   : write a message if the verbosity level is high enough
# Returns   : n/a
# Arguments : message : message string
#             level   : options verbosity level
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub verbose {

    # arguments
    my $message = shift;
    my $level   = shift;

    if ( !defined $message ) {
        $plugin->nagios_exit( UNKNOWN,
            q{Internal error: not enough parameters for 'verbose'} );
    }

    if ( !defined $level ) {
        $level = 0;
    }

    if ( $level < $verbosity ) {
        print $message;
    }

    return;

}

##############################################################################
# Usage     : usage() or usage("error message");
# Purpose   : prints the usage of the plugin and exits with unknown status
# Returns   : n/a
# Arguments : message : message string
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub usage {
    my $msg = shift;

    if ( defined $msg ) {
        print "$msg\n";
    }

    print << 'EOT';

check_lm_sensors [--help] [--verbose] [--version] [OPTIONS]

Options:

  -?, --help      help

  -l, --low       specifies a check for a sensor value which is too low.
                  Example:
                    --low fan1=2000,1000
                  will give a warning if the value of the fan1 sensor drops
                  below 2000 RPMs and a critical status if it drops below
                  1000 RPMs

  -h, --high      specifies a check for a sensor value which is too high.
                  Example:
                    --high temp1=50,60
                  will give a warning if the value of the temp1 sensor reaches
                  50 degrees and a critical status if it reaches 60 degrees

  -r, --range     specifies a check for a sensor value which should stay
                  in a given range.
                  Example:
                    --range v1=1,2,12
                  will give a warning if the value of the sensor gets outside
                  the 11-13 range (12+-1) and a critical status if the value is
                  outside the 10-14 range (12+-2)

  --rename        renames a sensor in the performance output (useful if you
                  want to have common names for similar sensors across
                  different machines)
                  Example:
                    --rename cputemp=temp1

  --list          list all available sensors

  --nosensors     disable checks on check lm_sensors

  --nodrives      disable checks on drive temperatures

  -d, --drives    enable checks on drive temperature

  --hddtemp_bin   manually specifies the location of the hddtemp binary

  -v, --verbose   verbose output

  --version       prints the version and exits

EOT

    $plugin->nagios_exit( UNKNOWN, 'Invalid arguments' );

    return;

}

##############################################################################
# Usage     : get_path('program_name');
# Purpose   : retrieves the path of an executable file using the
#             'which' utility
# Returns   : the path of the program (if found)
# Arguments : the program name
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub get_path {

    my $prog    = shift;
    my $command = "which $prog";
    my $output;
    my $path;

    my $pid = open $output, q{-|}, "$command 2>&1"
      or $plugin->nagios_exit( UNKNOWN, "Cannot execute $command: $OS_ERROR" );

    while (<$output>) {
        chomp;
        if ( !/^which:/mx ) {
            $path = $_;
        }
    }

    if (  !( close $output )
        && ( $OS_ERROR != 0 ) )
    {

        # close to a piped open return false if the command with non-zero
        # status. In this case $! is set to 0
        $plugin->nagios_exit( UNKNOWN,
            "Error while closing pipe to $command: $OS_ERROR\n" );
    }

    return $path;

}

##############################################################################
# Usage     : parse_drives()
# Purpose   : parses /proc/partitions to find available drives and tries to
#             get their temperature
# Returns   : n/a
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub parse_drives {

    my $IN;

    if ( -x $hddtemp_bin ) {

        verbose "Looking for drives in /proc/partitions\n";

        open $IN, '<', '/proc/partitions'
          or $plugin->nagios_exit( UNKNOWN, 'Cannot open /proc/partitions' );

        while (<$IN>) {

            chomp;

            my ( $major, $minor, $blocs, $name ) = split;

            if ( !defined $major || $major eq 'major' || $major eq q{} ) {
                next;
            }

            if ( $name =~ /[0-9]$/mx ) {
                next;
            }

            verbose "  checking disk /dev/$name\n", 1;

            my $command = "$hddtemp_bin -n /dev/$name";

            my $output;

            my $pid = open $output, q{-|}, "$command 2>&1"
              or $plugin->nagios_exit( UNKNOWN,
                "Cannot execute $command: $OS_ERROR" );

            while (<$output>) {
                chomp;

                if ( $_ =~ /^[0-9]+$/mx ) {

                    # check if the sensor has to be renamed
                    if ( $rename{$name} ) {
                        $name = $rename{$name};
                    }

                    $sensor_values{$name} = $_;


                    if ( $verbosity || $list ) {
                        print
                          "found temperature for drive $name ($name = $_)\n";
                    }

                }
                else {
                    verbose
                      "warning: temperature for /dev/$name not available\n";
                }

            }

            close $output
              or $plugin->nagios_exit( UNKNOWN,
                "Error while executing $command: $OS_ERROR\n" );

        }

        close $IN
          or $plugin->nagios_exit( UNKNOWN, "Cannot close input: $OS_ERROR\n" );

    }
    else {
        verbose
          "warning: $hddtemp_bin not found: HDD temperatures not checked\n";
    }

    return;

}

##############################################################################
# Usage     : parse_sensors()
# Purpose   : retrieves the values of the available sensors
# Returns   : n/a
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub parse_sensors {

    my $dir_handle;

    Readonly my $dev_dir => '/sys/class/hwmon';
    
    opendir $dir_handle, $dev_dir
        or return;

    my @devices = grep { m/^[^\.]/mxs } readdir $dir_handle;

    closedir $dir_handle
        or $plugin->nagios_exit( UNKNOWN, "Error closing $dev_dir: $OS_ERROR");    

    for my $device (@devices) {

        my $name;
        
        # get device name
        my $name_handler;
        open $name_handler, q{<}, "$dev_dir/$device/device/name"
            or $plugin->nagios_exit( UNKNOWN, "Error reading $dev_dir/$device/device/name: $OS_ERROR");
        
        while(<$name_handler>) {
            chomp;
            $name = $_;
            last;
        }

        close $name_handler
            or $plugin->nagios_exit( UNKNOWN, "Error closing $dev_dir/$device/device/name: $OS_ERROR");

        # list sensors
        opendir $dir_handle, "$dev_dir/$device/device/"
            or return;

        my @sensors = apply { s/_input//mxs; } grep { m/^[^\.].*_input/mxs } readdir $dir_handle;

        closedir $dir_handle
            or $plugin->nagios_exit( UNKNOWN, "Error closing $dev_dir/$device/device: $OS_ERROR");

        for my $sensor (@sensors) {

            # get device name
            my $sensor_handler;
            my $value;
            
            open $sensor_handler, q{<}, "$dev_dir/$device/device/$sensor".'_input'
                or $plugin->nagios_exit( UNKNOWN, "Error reading $dev_dir/$device/device/$sensor"."_input: $OS_ERROR");
            
            while(<$sensor_handler>) {
                chomp;
                $value=$_;
                last;
            }

            close $sensor_handler
                or $plugin->nagios_exit( UNKNOWN, "Error closing $dev_dir/$device/device/$sensor"."_input: $OS_ERROR");

            my $full_name = $name . q{_} . $sensor;
            
            # check if the sensor has to be renamed
            if ( $rename{$full_name} ) {
                $full_name = $rename{$full_name};
            }
            
            $sensor_values{$full_name} = $value;
            
            if ( $verbosity || $list ) {
                print "found sensor $full_name ($value)\n";
            }
            
        }
        
    }
            
    return;
    

}

##############################################################################
# main
#

########################
# Command line arguments

Getopt::Long::Configure( 'bundling', 'no_ignore_case' );
$result = GetOptions(
    'drives!'       => \$drives,
    'hddtemp_bin=s' => \$hddtemp_bin,
    'help|?'        => sub { usage() },
    'high|h=s'      => \%highs,
    'list'          => \$list,
    'low|l=s'       => \%lows,
    'range|r=s'     => \%ranges,
    'sensors!'      => \$sensors,
    'verbose|v+'    => \$verbosity,
    'version' => sub { print "check_lm_sensors version $VERSION\n"; exit 3; }
);

if ( !$result ) {
    usage();
}

if (   !( defined $list )
    && !(%highs)
    && !(%ranges)
    && !(%lows) )
{
    $plugin->nagios_exit( UNKNOWN, 'at least one check has to be specified' );
}

if ($drives) {
    if ( !$hddtemp_bin ) {
        $hddtemp_bin = get_path('hddtemp');
    }
    if ( !$hddtemp_bin ) {
        verbose "warning: hddtemp not found: HDD temperatures not checked\n";
    }
    else {
        verbose "hddtemp found at $hddtemp_bin\n";
        parse_drives();
    }
}

parse_sensors();

################
# perform checks

# lows
while ( ( $name, $limits ) = each %lows ) {

    $converted_name = $name;
    $converted_name =~ s/_/\ /gmx;

    if ( !$sensor_values{$name} && $sensor_values{$converted_name} ) {
        $name = $converted_name;
    }
    if ( !$sensor_values{$name} ) {
        $unknowns = $unknowns . " $name";
        next;
    }

    my ( $warn, $crit ) = split /,/mx, $limits;

    my $value = $sensor_values{$name};

    if ( $value < $crit ) {
        $criticals = $criticals . " $name=" . $sensor_values{$name};
    }
    elsif ( $value < $warn ) {
        $warnings = $warnings . " $name=" . $sensor_values{$name};
    }

    if ($space) {
        $status = $status . q{ };
    }
    $status = $status . "$name=$value;$warn;$crit;;";
    $desc   = $desc . "$name=$value";
    $space  = 1;

}

# highs
while ( ( $name, $limits ) = each %highs ) {

    $converted_name = $name;
    $converted_name =~ s/_/\ /gmx;

    if ( !$sensor_values{$name} && $sensor_values{$converted_name} ) {
        $name = $converted_name;
    }
    if ( !$sensor_values{$name} ) {
        $unknowns = $unknowns . " $name";
        next;
    }

    my ( $warn, $crit ) = split /,/mx, $limits;

    my $value = $sensor_values{$name};

    if ( $value > $crit ) {
        $criticals = $criticals . " $name=" . $sensor_values{$name};
    }
    elsif ( $value > $warn ) {
        $warnings = $warnings . " $name=" . $sensor_values{$name};
    }

    if ($space) {
        $status = $status . q{ };
        $desc   = $desc . q{ };
    }
    $status = $status . "$name=$value;$warn;$crit;;";
    $desc   = $desc . "$name=$value";
    $space  = 1;

}

# ranges
while ( ( $name, $limits ) = each %ranges ) {

    $converted_name = $name;
    $converted_name =~ s/_/\ /gmx;

    if ( !$sensor_values{$name} && $sensor_values{$converted_name} ) {
        $name = $converted_name;
    }
    if ( !$sensor_values{$name} ) {
        $unknowns = $unknowns . " $name";
        next;
    }

    my ( $warn, $crit, $ref ) = split /,/mx, $limits;

    my $value = $sensor_values{$name};
    my $diff  = $value;

    $diff = abs( $value - $ref );

    if ( $diff > $crit ) {
        $criticals = $criticals . " $name=" . $sensor_values{$name};
    }
    elsif ( $diff > $warn ) {
        $warnings = $warnings . " $name=" . $sensor_values{$name};
    }

    if ($space) {
        $status = $status . q{ };
        $desc   = $desc . q{ };
    }
    $status = $status . "$name=$value;$warn;$crit;;";
    $desc   = $desc . "$name=$value";
    $space  = 1;

}

#########################
# build the status string

if ( $criticals ne q{} ) {
    $plugin->nagios_exit( CRITICAL, "$desc|$status" );
}

if ( $warnings ne q{} ) {
    $plugin->nagios_exit( WARNING, "$desc|$status" );
}

if ( $unknowns ne q{} ) {
    $plugin->nagios_exit( UNKNOWN, "$desc|$status" );
}

$plugin->nagios_exit( OK, "$desc|$status" );

1;

