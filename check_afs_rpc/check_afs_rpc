#!perl

# check_afs_rpc is a Nagios plugin to check for the RPC status of an AFS
# server by using rxdebug
#
# See  the INSTALL file for installation instructions
#
# Copyright (c) 2007, ETH Zurich.
#
# based on check_rxdebug by Quanah Gibson-Mount, Neil Crellin, and Russ Allbery
#
# This module is free software; you can redistribute it and/or modify it
# under the terms of GNU general public license (gpl) version 3.
# See the LICENSE file for details.
#
# RCS information
# enable substitution with:
#   $ svn propset svn:keywords "Id Revision HeadURL Source Date"
#
#   $Id$
#   $Revision$
#   $HeadURL$
#   $Date$

use 5.008;
use strict;
use warnings;
use Carp;

use version; our $VERSION = '1.0.2';

use English qw(-no_match_vars);
use Getopt::Long;
use Nagios::Plugin::Threshold;
use Nagios::Plugin;
use POSIX qw(uname);

# IMPORTANT: Nagios plugins could be executed using embedded perl in this case
#            the main routine would be executed as a subroutine and all the
#            declared subroutines would therefore be inner subroutines
#            This will cause all the global lexical variables not to stay shared
#            in the subroutines!
#
# All variables are therefore declared as package variables...
#
use vars qw(
  $blocked
  $command
  $critical
  $hostname
  $output
  $plugin
  $port
  $verbosity
  $result
  $rxdebug_bin
  $threshold
  $timeout
  $warning
);

##############################################################################
# Usage     : usage()
# Purpose   : prints a usage message
# Returns   : n/a
# Arguments : -message : an optional error message
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub usage {

    my %args = @_;

    my $exitval = 0;
    if ($args{-exitval}) {
        $exitval = $args{-exitval};
    }
    
    if ($args{-message}) {
        print $args{-message};
    }

    print<<'EOT';

        check_rxdebug [OPTIONS] --hostname hostname

        Mandatory arguments:
         --hostname,-H   hostname   name of the AFS server

        Options:
         --critical,-c   critical   specify the critical number of blocked
                                    connections (default 8)
         --help,-h,-?               usage info
         --port,p        port       connection port (default 7000)
         --version,V                print version number
         --warning,-w    warning    specify warning threshold for the number
                                    blocked connections (default 2)

EOT

    exit $exitval;
    
}

##############################################################################
# Usage     : verbose("some message string", $optional_verbosity_level);
# Purpose   : write a message if the verbosity level is high enough
# Returns   : n/a
# Arguments : message : message string
#             level   : options verbosity level
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub verbose {

    # arguments
    my $message   = shift;
    my $level     = shift;

    if ( !defined $message) {
        $plugin->nagios_exit(UNKNOWN, q{Internal error: not enough parameters for 'verbose'});
    }
    
    if ( !defined $level ) {
        $level = 0;
    }

    if ( $level < $verbosity ) {
        print $message;
    }

    return;

}

##############################################################################
# Usage     : get_path('program_name');
# Purpose   : retrieves the path of an executable file using the
#             'which' utility
# Returns   : the path of the program (if found)
# Arguments : the program name
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub get_path {

    my $prog = shift;
    my $path;

    $command = "which $prog";

    open $output, q{-|}, "$command 2>&1"
      or $plugin->nagios_exit( UNKNOWN, "Cannot execute $command: $OS_ERROR" );

    while (<$output>) {
        chomp;
        if ( !/^which:/mx ) {
            $path = $_;
        }
    }

    if ( !( close $output )
        && ( $OS_ERROR != 0 ) )
    {

        # close to a piped open return false if the command with non-zero
        # status. In this case $! is set to 0
        $plugin->nagios_exit( UNKNOWN,
            "Error while closing pipe to $command: $OS_ERROR\n" );
    }

    return $path;

}

################################################################################
# Main

################
# Initialization

# The default count of blocked connections at which to warn or send a
# critical alert.  These can be overridden with the -w and -c
# command-line options.
$critical = 8;
$warning  = 2;

$verbosity = 0;

# The default timeout in seconds (implemented by alarm) for rxdebug.
$timeout = 60;

$rxdebug_bin = get_path('rxdebug');
$port        = 7_000;

$plugin = Nagios::Plugin->new( shortname => 'CHECK_AFS_RPC' );

##############################
# Process command line options

Getopt::Long::config( 'bundling', 'no_ignore_case' );
$result = GetOptions(
    'critical|c=i' => \$critical,
    'hostname|H=s' => \$hostname,
    'help|h|?'     => sub {
        usage(
            -exitval => UNKNOWN,
        );
        exit UNKNOWN, },
    'port|p=i',    => \$port,
    'timeout|t=i'  => \$timeout,
    'verbose|v+'   => \$verbosity,
    'version|V'    => sub { print "check_afs_rpc version $VERSION\n"; exit 3; },
    'warning|w=i'  => \$warning
);

###############
# sanity checks

if ( !defined $hostname ) {
    usage( -message =>
          'Error: please specify an AFS server with the --hostname option'
      );
}
if ( !defined $rxdebug_bin ) {
    usage( -message =>
'Cannot find the rxdebug binary: please specify it with the --rxdebug option'
    );
}
if ( !-x $rxdebug_bin ) {
    usage( -message => "$rxdebug_bin is not executable" );
}

$threshold = Nagios::Plugin::Threshold->set_thresholds(
    warning  => $warning,
    critical => $critical,
);

####################
# Set up the timeout
$SIG{ALRM} = sub {
    $plugin->nagios_exit( UNKNOWN,
        "AFS_RPC CRITICAL: network timeout after $timeout seconds\n",
    );
};
alarm $timeout;

##################################
# Run rxdebug and parse the output

$command = "$rxdebug_bin -noconn $hostname -port $port";

verbose "Executing $command\n";

open $output, q{-|}, "$command 2>&1"
  or $plugin->nagios_exit( UNKNOWN, "Cannot execute $command: $OS_ERROR", );

undef $blocked;
while (<$output>) {
    if (/^(\d+)\ calls\ waiting\ for\ a\ thread/mx) {
        $blocked = $1;
        last;
    }
}

if ( !( close $output )
    && ( $OS_ERROR != 0 ) )
{

    # close to a piped open return false if the command with non-zero
    # status. In this case $! is set to 0
    $plugin->nagios_exit( UNKNOWN,
        "Error while closing pipe to $command: $OS_ERROR\n" );
}

if ( !defined $blocked ) {
    $plugin->nagios_exit( UNKNOWN, 'Cannot parse rxdebug output', );
}

$plugin->add_perfdata(
    label     => 'blocked',
    value     => $blocked,
    uom       => q{},
    threshold => $threshold,
);

$plugin->nagios_exit( $threshold->get_status($blocked), "blocked = $blocked", );

1;
