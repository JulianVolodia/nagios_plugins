#!perl

# check_updates is a Nagios plugin to check if RedHat or Fedora system
# is up-to-date
#
# See  the INSTALL file for installation instructions
#
# Copyright (c) 2007, ETH Zurich.
#
# This module is free software; you can redistribute it and/or modify it
# under the terms of GNU general public license (gpl) version 3.
# See the LICENSE file for details.
#
# RCS information
# enable substitution with:
#   $ svn propset svn:keywords "Id Revision HeadURL Source Date"
#
#   $Id$
#   $Revision$
#   $HeadURL$
#   $Date$

use 5.008;
use strict;
use warnings;
use Carp;

use version; our $VERSION = '1.0.2';

use English qw(-no_match_vars);
use Getopt::Long;
use List::MoreUtils qw(any);
use List::Util qw(first);
use Nagios::Plugin::Threshold;
use Nagios::Plugin;
use Number::Format qw(format_number);
use POSIX qw(uname);
use Pod::Usage qw(pod2usage);
use Sort::Versions;

# IMPORTANT: Nagios plugins could be executed using embedded perl in this case
#            the main routine would be executed as a subroutine and all the
#            declared subroutines would therefore be inner subroutines
#            This will cause all the global lexical variables not to stay shared
#            in the subroutines!
#
# All variables are therefore declared as package variables...
#
use vars qw(
  $critical
  $help
  $plugin
  $threshold
  $verbosity
  $warning
);

##############################################################################
# subroutines

##############################################################################
# Usage     : whoami()
# Purpose   : retrieve the user runnging the process
# Returns   : username
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub whoami {
    my $output;
    my $pid = open $output, q{-|}, 'whoami'
      or
      $plugin->nagios_exit( UNKNOWN, "Cannot determine the user: $OS_ERROR" );
    while (<$output>) {
        chomp;
        return $_;
    }
    $plugin->nagios_exit( UNKNOWN, 'Cannot determine the user' );
    return;
}

##############################################################################
# Usage     : verbose("some message string", $optional_verbosity_level);
# Purpose   : write a message if the verbosity level is high enough
# Returns   : n/a
# Arguments : message : message string
#             level   : options verbosity level
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub verbose {

    # arguments
    my $message = shift;
    my $level   = shift;

    if ( !defined $message ) {
        $plugin->nagios_exit( UNKNOWN,
            q{Internal error: not enough parameters for 'verbose'} );
    }

    if ( !defined $level ) {
        $level = 0;
    }

    if ( $level < $verbosity ) {
        print $message;
    }

    return;

}

##############################################################################
# Usage     : check_running_kernel( $package );
# Purpose   : checks if the loaded kernel is the latest available
# Returns   : n/a
# Arguments : $package : the kernel package name (e.g., kenerl or kernel-smp)
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub check_running_kernel {

    use RPM2;

    my $package = shift;

    my ( $sysname, $nodename, $release, $version, $machine ) = POSIX::uname();

    # remove the trailing arch displayed on some systems (F9)

    $release =~ s/\.(i[3-6]86|ppc|x86_64)$//mx;

    verbose "running a Linux kernel: $release\n";

    my $rpm_db  = RPM2->open_rpm_db();
    my @kernels = $rpm_db->find_by_name($package);

    my @versions;

    for my $header (@kernels) {

        push @versions,
          $header->tag('Version') . q{-} . $header->tag('Release');
    }

    @versions = sort versioncmp @versions;

    my $installed = $versions[-1];
    if ( $package =~ /-smp$/mx ) {
        $installed .= 'smp';
    }

    verbose "kernel: running = $release, installed = $installed\n";

    if ( $installed ne $release ) {

        if ($critical) {
            $critical .=
"the running kernel $release is not up-to-date (kernel $versions[-1] is installed)";
        }
        else {
            $critical =
"the running kernel $release is not up-to-date (kernel $versions[-1] is installed)";
        }

    }

    return;

}

##############################################################################
# Usage     : check_yum();
# Purpose   : checks a yum based system for updates
# Returns   : n/a
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub check_yum {

    my $redirection = q{};
    if ( $verbosity < 2 ) {
        $redirection = '> /dev/null 2>&1';
    }

    my $ret = system("yum check-update $redirection") >> 8;

    if ( $ret == 100 ) {

        # count the packages

        my $output;
        my $updates;
        my $pid = open $output, q{-|},
          q{yum check-update | sed -e '1,/^$/ d' | wc -l}
          or $plugin->nagios_exit( UNKNOWN, "Cannot list updates: $OS_ERROR" );
        while (<$output>) {
            chomp;
            $updates = $_;
            last;
        }

        my $message = $updates . ' update';
        if ( $updates > 1 ) {
            $message = $message . q{s};
        }
        $message = $message . ' available';
        $plugin->add_perfdata(
            label     => 'updates',
            value     => $updates,
            uom       => q{},
            threshold => $threshold,
        );

        if ($critical) {
            $critical .= $message;
        }
        else {
            $critical = $message;
        }

    }
    else {

        $plugin->add_perfdata(
            label     => 'updates',
            value     => 0,
            uom       => q{},
            threshold => $threshold,
        );

        if ($critical) {
            $plugin->nagios_exit( CRITICAL, $critical );
        }
        else {
            $plugin->nagios_exit( OK, 'no updates available' );
        }

    }

    return;

}

##############################################################################
# Usage     : check_up2date();
# Purpose   : checks an up2date based system for updates
# Returns   : n/a
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub check_up2date {

    # parsing the output of up2date -l

    if ( whoami() ne 'root' ) {
        $plugin->nagios_exit( CRITICAL,
            q{must be root to execute 'up2date -l': use sudo} );
    }

    my $output;
    my $updates;
    my $pid = open $output, q{-|},
q{up2date -l | grep -A 64 -- '----------------------------------------------------------' | grep [a-z] | wc -l}
      or $plugin->nagios_exit( UNKNOWN, "Cannot list updates: $OS_ERROR" );
    while (<$output>) {
        chomp;
        $updates = $_;
        last;
    }

    if ( $updates > 0 ) {
        chomp $updates;
        my $message = $updates . ' update';
        if ( $updates > 1 ) {
            $message = $message . q{s};
        }
        $message = $message . ' available';
        $plugin->add_perfdata(
            label     => 'updates',
            value     => $updates,
            uom       => q{},
            threshold => $threshold,
        );

        if ($critical) {
            $critical .= " $message";
        }
        else {
            $critical = $message;
        }

    }
    else {

        $plugin->add_perfdata(
            label     => 'updates',
            value     => 0,
            uom       => q{},
            threshold => $threshold,
        );

    }

    return;

}

##############################################################################
# main
#

################
# initialization
$help      = q{};
$verbosity = 0;
$plugin    = Nagios::Plugin->new( shortname => 'CHECK_UPDATES' );
$threshold = Nagios::Plugin::Threshold->set_thresholds(
    warning  => 0,
    critical => 0,
);

########################
# Command line arguments

Getopt::Long::Configure(qw{bundling });
my $result = GetOptions(
    'help|h|?'   => \$help,
    'verbose|v+' => \$verbosity,
    'version|V'  => sub { print "check_updates version $VERSION\n"; exit 3; }
);

if ( !$result || $help ) {
    pod2usage();
}

verbose "Checking a $^O system\n";

if ( $OSNAME eq 'linux' ) {

    if ( -r '/etc/issue' ) {

        my $header;
        my $TMP;

        open $TMP, q{<}, '/etc/issue'
          or $plugin->nagios_exit( CRITICAL,
            "Error opening /etc/issue: $OS_ERROR" );
        while (<$TMP>) {
            chomp;
            $header = $_;
            last;
        }
        close $TMP
          or $plugin->nagios_exit( CRITICAL,
            "Error closing /etc/issue: $OS_ERROR" );

        if ( $header =~ /Fedora/mx ) {
            verbose "Fedora detected: using yum\n";
            check_running_kernel('kernel');
            check_yum();
        }
        elsif ( $header =~ /CentOS/mx ) {
            verbose "CentOS detected: using yum\n";
            check_running_kernel('kernel-smp');
            check_yum();
        }
        elsif ( $header =~ /Red\ Hat/mx ) {
            verbose "RedHat detected: using up2date\n";
            check_running_kernel('kernel-smp');
            check_up2date();
        }
        else {
            $plugin->nagios_exit( UNKNOWN, 'unknown Linux distribution' );
        }

        if ($critical) {
            $plugin->nagios_exit( CRITICAL, $critical );
        }
        else {
            $plugin->nagios_exit( OK, 'no updates available' );
        }

    }
    else {
        $plugin->nagios_exit( UNKNOWN,
            'Cannot detect Linux distribution (no /etc/issue file)' );
    }

}

1;
