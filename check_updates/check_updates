#!perl

# check_updates is a Nagios plugin to check if RedHat or Fedora system
# is up-to-date
#
# See  the INSTALL file for installation instructions
#
# Copyright (c) 2007, ETH Zurich.
#
# This module is free software; you can redistribute it and/or modify it
# under the terms of GNU general public license (gpl) version 3.
# See the LICENSE file for details.
#
# RCS information
# enable substitution with:
#   $ svn propset svn:keywords "Id Revision HeadURL Source Date"
#
#   $Id$
#   $Revision$
#   $HeadURL$
#   $Date$

use 5.008;
use strict;
use warnings;
use Carp;

use version; our $VERSION = '1.2.0';

use English qw(-no_match_vars);
use List::MoreUtils qw(any);
use List::Util qw(first);
use Nagios::Plugin::Getopt;
use Nagios::Plugin::Threshold;
use Nagios::Plugin;
use Number::Format qw(format_number);
use POSIX qw(uname);
use Sort::Versions;

use Readonly;

Readonly my $EXIT_UNKNOWN                 => 3;
Readonly my $YUM_RETURN_UPDATES_AVAILABLE => 100;

# IMPORTANT: Nagios plugins could be executed using embedded perl in this case
#            the main routine would be executed as a subroutine and all the
#            declared subroutines would therefore be inner subroutines
#            This will cause all the global lexical variables not to stay shared
#            in the subroutines!
#
# All variables are therefore declared as package variables...
#
use vars qw(
  $bootcheck
  $critical
  $help
  $options
  $plugin
  $threshold
  $warning
);

##############################################################################
# subroutines

##############################################################################
# Usage     : whoami()
# Purpose   : retrieve the user runnging the process
# Returns   : username
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub whoami {
    my $output;
    my $pid = open $output, q{-|}, 'whoami'
      or
      $plugin->nagios_exit( UNKNOWN, "Cannot determine the user: $OS_ERROR" );
    while (<$output>) {
        chomp;
        return $_;
    }
    close $output
        or $plugin->nagios_exit( UNKNOWN, "Cannot determine the user: $OS_ERROR" );
    
    $plugin->nagios_exit( UNKNOWN, 'Cannot determine the user' );
    return;
}

##############################################################################
# Usage     : verbose("some message string", $optional_verbosity_level);
# Purpose   : write a message if the verbosity level is high enough
# Returns   : n/a
# Arguments : message : message string
#             level   : options verbosity level
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub verbose {

    # arguments
    my $message = shift;
    my $level   = shift;

    if ( !defined $message ) {
        $plugin->nagios_exit( UNKNOWN,
            q{Internal error: not enough parameters for 'verbose'} );
    }

    if ( !defined $level ) {
        $level = 0;
    }

    if ( $level < $options->verbose ) {
        print $message;
    }

    return;

}

##############################################################################
# Usage     : check_running_kernel( $package );
# Purpose   : checks if the loaded kernel is the latest available
# Returns   : n/a
# Arguments : $package : the kernel package name (e.g., kenerl or kernel-smp)
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub check_running_kernel {

    if ( !$bootcheck ) {
        return;
    }

    my $package = shift;

    my ( $sysname, $nodename, $release, $version, $machine ) = POSIX::uname();

    # remove the trailing arch displayed on some systems (F9)

    $release =~ s/\.(i[3-6]86|ppc|x86_64)$//mxs;

    # remove smp

    $release =~ s/smp$//mxs;

    # remove RH flavour

    $release =~ s/\.EL$//mxs;

    verbose "running a Linux kernel: $release\n";

    my @versions;

    my $output;
    my $pid = open $output, q{-|}, q{rpm -q kernel}
      or $plugin->nagios_exit( UNKNOWN,
        "Cannot list installed kernels: $OS_ERROR" );
    while (<$output>) {

        my $version = $_;

        chomp $version;

        # strip package name
        $version =~ s/^kernel-//mxs;

        # strip architecture
        $version =~ s/\.[^\.]*$//mxs;

        push @versions, $version;
    }

    close $output
      or $plugin->nagios_exit( UNKNOWN,
        "Cannot list installed kernels: $OS_ERROR" );
    
    @versions = sort versioncmp @versions;

    my $installed = $versions[-1];

    verbose "kernel: running = $release, installed = $installed\n";

    if ( $installed ne $release ) {

        my $error =
"your machine is running kernel $release but a newer version ($installed) is installed: you should reboot";

        if ($critical) {
            $critical .= $error;
        }
        else {
            $critical = $error;
        }

    }

    return;

}

##############################################################################
# Usage     : check_yum();
# Purpose   : checks a yum based system for updates
# Returns   : n/a
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub check_yum {

    my $redirection = q{};
    if ( $options->verbose < 2 ) {
        $redirection = '> /dev/null 2>&1';
    }

    my $ret = system("yum check-update $redirection") >> 8;

    if ( $ret == $YUM_RETURN_UPDATES_AVAILABLE ) {

        # count the packages

        verbose "yum reports a non-up-to-date system\n";

        my $output;
        my $updates;

        # run yum check update and remove everything
        # up to the first empty line, then count
        # the listed updates

        my $pid = open $output, q{-|},
          q{yum check-update | sed -e '0,/^$/ d' | wc -l}
          or $plugin->nagios_exit( UNKNOWN, "Cannot list updates: $OS_ERROR" );
        while (<$output>) {
            chomp;
            $updates = $_;
            last;
        }

        close $output
            or $plugin->nagios_exit(
                UNKNOWN,
                "Cannot list list updates: $OS_ERROR"
            );

        my $message = $updates . ' update';
        if ( $updates > 1 ) {
            $message = $message . q{s};
        }
        $message = $message . ' available';
        $plugin->add_perfdata(
            label     => 'updates',
            value     => $updates,
            uom       => q{},
            threshold => $threshold,
        );

        if ($critical) {
            $critical .= q{, } . $message;
        }
        else {
            $critical = $message;
        }

    }
    else {

        verbose "yum reports an up-to-date system\n";

        $plugin->add_perfdata(
            label     => 'updates',
            value     => 0,
            uom       => q{},
            threshold => $threshold,
        );

        if ($critical) {
            $plugin->nagios_exit( CRITICAL, $critical );
        }
        else {
            $plugin->nagios_exit( OK, 'no updates available' );
        }

    }

    return;

}

##############################################################################
# Usage     : check_up2date();
# Purpose   : checks an up2date based system for updates
# Returns   : n/a
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub check_up2date {

    # parsing the output of up2date -l

    if ( whoami() ne 'root' ) {
        $plugin->nagios_exit( CRITICAL,
            q{must be root to execute 'up2date -l': use sudo} );
    }

    my $output;
    my $updates;

    my $command =
q{/usr/sbin/up2date -lf | /bin/grep -A 64 -- '----------------------------------------------------------' | /bin/grep '[[:alpha:]]' | wc -l};

    my $pid = open $output, q{-|}, $command
      or $plugin->nagios_exit( UNKNOWN, "Cannot list updates: $OS_ERROR" );

    while (<$output>) {
        chomp;
        $updates = $_;
        last;
    }

    close $output
        or $plugin->nagios_exit( UNKNOWN, "Cannot list updates: $OS_ERROR" );
    
    if ( $updates > 0 ) {
        chomp $updates;
        my $message = $updates . ' update';
        if ( $updates > 1 ) {
            $message = $message . q{s};
        }
        $message = $message . ' available';
        $plugin->add_perfdata(
            label     => 'updates',
            value     => $updates,
            uom       => q{},
            threshold => $threshold,
        );

        if ($critical) {
            $critical .= " $message";
        }
        else {
            $critical = $message;
        }

    }
    else {

        $plugin->add_perfdata(
            label     => 'updates',
            value     => 0,
            uom       => q{},
            threshold => $threshold,
        );

    }

    return;

}

##############################################################################
# main
#

################
# initialization
$help      = q{};
$bootcheck = 1;
$plugin    = Nagios::Plugin->new( shortname => 'CHECK_UPDATES' );
$threshold = Nagios::Plugin::Threshold->set_thresholds(
    warning  => 0,
    critical => 0,
);

########################
# Command line arguments

$options = Nagios::Plugin::Getopt->new(
    usage   => 'Usage: %s [--help] [--verbose] [--version] [--timeout t]',
    version => $VERSION,
    url     => 'https://trac.id.ethz.ch/projects/nagios_plugins',
    blurb   => 'Checks if RedHat or Fedora system is up-to-date', 
);

$options->arg(
    spec => 'boot-check',
    help => 'Check if the machine was booted with the newest kernel (default)',
);

$options->arg(
    spec => 'no-boot-check',
    help => 'do not complain if the machine was booted with an old kernel',
);


$options->getopts();

# check bootcheck consistency
if ($options->get('boot-check') && $options->get('no-boot-check')) {
    $plugin->nagios_exit(
        CRITICAL,
        'Error --boot-check and --no-boot-check specified at the same time'
    );
}

if ($options->get('no-boot-check')) {
    $bootcheck = 0;
}

#########
# Timeout

alarm $options->timeout;

verbose "Checking a $^O system\n";

if ( $OSNAME eq 'linux' ) {

    if ( -r '/etc/issue' ) {

        my $header;
        my $TMP;

        open $TMP, q{<}, '/etc/issue'
          or $plugin->nagios_exit( CRITICAL,
            "Error opening /etc/issue: $OS_ERROR" );
        while (<$TMP>) {
            chomp;
            $header = $_;
            last;
        }
        close $TMP
          or $plugin->nagios_exit( CRITICAL,
            "Error closing /etc/issue: $OS_ERROR" );

        if ( $header =~ /Fedora/mxs ) {
            verbose "Fedora detected: using yum\n";
            check_running_kernel('kernel');
            check_yum();
        }
        elsif ( $header =~ /CentOS/mxs ) {
            verbose "CentOS detected: using yum\n";
            check_running_kernel('kernel-smp');
            check_yum();
        }
        elsif ( $header =~ /Red\ Hat/mxs ) {
            verbose "RedHat detected: using up2date\n";
            check_running_kernel('kernel-smp');
            check_up2date();
        }
        else {
            $plugin->nagios_exit( UNKNOWN, 'unknown Linux distribution' );
        }

        if ($critical) {
            $plugin->nagios_exit( CRITICAL, $critical );
        }
        else {
            $plugin->nagios_exit( OK, 'no updates available' );
        }

    }
    else {
        $plugin->nagios_exit( UNKNOWN,
            'Cannot detect Linux distribution (no /etc/issue file)' );
    }

}

1;
