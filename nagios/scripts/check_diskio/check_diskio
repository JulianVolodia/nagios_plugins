#!/usr/bin/perl

use strict;
use Getopt::Long;

my $VERSION    = "0.1";

my $tmp        = '/tmp/check_diskio_status';
my $name       = "DISKIO";

my $critical   = 0;
my $help       = '';
my $device     = '';
my $reset      = '';
my $result;
my $status     = 0;
my $status_msg = '';
my $warning    = 0;

##############################################################################
# subroutines

################################
# prints the usage of the plugin
sub usage {
  my $msg = shift;

  if (defined $msg) {
    print "$msg\n";
  }

  print << "EOT";
usage:
  -c crit, --critical=crit      critical
  -d device, --device=device    device
  -r, --reset                   reset the counter
  -w warn, --warning warn       warning
  -v, --version                 version
EOT
  exit(3);
}

#################################################
# prints an "unknown" error message (exit code 3)
sub unknown {

  my $msg = shift;

  if (defined $msg) {
    print "$name UNKNOWN: $msg\n";
  }

  exit(3);

}

#################################################
# writes the time and transmit data to
# the temporary file
sub write_timer {

    my $in  = shift;
    my $out = shift;
    
    open(TMP, "> $tmp") or
        unknown("Cannot initialize timer");
    print TMP time . " $in $out\n";
    close TMP or
        unknown("Cannot close timer");
}


##############################################################################
# main
#

########################
# Command line arguments

$result = GetOptions (
    "critical=i"  => \$critical,
    "device=s"    => \$device,
    "help"        => \$help,
    "reset"       => \$reset,
    "warning=i"   => \$warning,
    "version"     => sub { print "check_dir version $VERSION\n"; exit 3;}
);

if (!$result) {
  usage();
}

if ($help)                { usage(); }
if ($critical <= 0)       { usage("Could not parse \"critical\"");  }
if (!$device)             { usage("Could not parse \"device\"");    }
if ($warning  <= 0)       { usage("Could not parse \"warning\"");   }
if ($critical < $warning) { usage("\"critical\" has to be greater than \"warning\""); }

# we need one temporary file per interface
$tmp = $tmp . "-$device";

########################
# Check the proc entry

my $diff;
my $found  = 0;
my $in;
my $out;
my $time;

open(IN,"/proc/diskstats") or
    unknown("Cannot open /proc/diskstats");

while(<IN>) {

    chomp;

    # /proc/diskstats format
    #
    # major         Major number
    # minor         Minor number
    # name          Name
    # reads         This is the total number of reads completed successfully.
    # merged        Reads and writes which are adjacent to each other may be merged for
    #               efficiency.  Thus two 4K reads may become one 8K read before it is
    #               ultimately handed to the disk, and so it will be counted (and queued)
    #               as only one I/O.  This field lets you know how often this was done.
    # s_read        This is the total number of sectors read successfully.
    # ms_read       This is the total number of milliseconds spent by all reads.
    # writes        This is the total number of writes completed successfully.
    # s_write       This is the total number of sectors written successfully.
    # ms_write      This is the total number of milliseconds spent by all writes.
    # ios           The only field that should go to zero. Incremented as requests are
    #               given to appropriate request_queue_t and decremented as they finish.
    # ms_io         This field is increases so long as field 9 is nonzero.
    # ms_weighted   This field is incremented at each I/O start, I/O completion, I/O
    #               merge, or read f these stats by the number of I/Os in progress
    #               times the number of milliseconds spent doing I/O since the
    #               last update of this field.  This can provide an easy measure of both
    #               I/O completion time and the backlog that may be accumulating.

    my ($major,
        $minor,
        $name,
        $reads,
        $merged,
        $s_read,
        $ms_read,
        $writes,
        $s_write,
        $ms_write,
        $ios,
        $ms_io,
        $ms_weighted) = split;

    if ($name eq $device) {

        $found = 1;

        # get the time difference
        if ($reset || !open(TMP, $tmp)) {
            write_timer($s_write, $s_read);
            unknown("Initializing timer");
        }
            
        while (<TMP>) {
            chomp;
            ($time, $in, $out) = split;
            $diff = time - $time;
        }
              
        close(TMP);
        
        write_timer($s_write, $s_read);

        if ($diff > 400) {
            # time difference is > 400s
            # since the counter could overflow
            # we reeinitilize the timer
            write_timer($s_write, $s_read);
            unknown("Time difference too big: initializing");
        }

        if ($diff == 0) {
            # round up
            $diff = 1;
        }

        my $diskio_w = abs(int(($s_write - $in)  / $diff));
        my $diskio_r = abs(int(($s_read  - $out) / $diff));
        my $diskio   = $diskio_w + $diskio_r;

        my $performance = "TOTAL=$diskio;$warning;$critical;;"
            ." WRITE=$diskio_w;;;;"
            ." READ=$diskio_r;;;;"
            ." TIME=$diff;;;;";
            
        if ($diskio < $warning) {
            print "$name OK $diskio sectors/s|$performance\n";
            exit 0;
        } else {
            if ($diskio < $critical) {
                print "$name WARNING $diskio sectors/s|$performance\n";
                exit 1;
            } else {
                print "$name CRITICAL $diskio sectors/s|$performance\n";
                exit 2;
            }
        }
            
        warning("Implementation error");
            
        last;
        
    }
        
}

close(IN);

if (!$found) {
    unknown("Device $device not found");
}
